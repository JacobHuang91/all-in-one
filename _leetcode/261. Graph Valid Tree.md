---
title: 261. Graph Valid Tree
tags: LeetCode
categories: LeetCode
date: 2020-09-26 10:42:11
keywords:
description:
cover:
top_img:
toc:
toc_number:
copyright:
indexing:
layout: post
---

## YouTube Video

## Problem

Given n nodes labeled from 0 to n-1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.

Example 1:

```
Input: n = 5, and edges = [[0,1], [0,2], [0,3], [1,4]]
Output: true
```

Example 2:

```
Input: n = 5, and edges = [[0,1], [1,2], [2,3], [1,3], [1,4]]
Output: false
```

Note: you can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0,1] is the same as [1,0] and thus will not appear together in edges.

## Code

```python
class Solution:
    def validTree(self, n: int, edges: List[List[int]]) -> bool:
        # 1. 不会构成连通图 2. 没有孤立的点
        graph = defaultdict(list)

        for edge in edges:
            graph[edge[0]].append(edge[1])
            graph[edge[1]].append(edge[0])

        visited = set()
        visited.add(0)

        res = self.helper(graph, visited, 0, -1)

        if not res:
            return False

        return True if len(visited) == n else False

    def helper(self, graph: List[List[int]], visited: Set[int], node: int, parent: int):
        subs = graph[node]

        for sub in subs:
            if sub == parent:
                continue

            if sub in visited:
                return False

            visited.add(sub)
            res = self.helper(graph, visited, sub, node)

            if not res:
                return False

        return True
```

Time Complexity : O(N + E).
Space Complexity : O(N + E).

```python
class UnionFind:
    def __init__(self, n: int):
        self.parents = [i for i in range(n)]
        self.ranks = [1] * n

    def union(self, u: int, v: int) -> bool:
        pu = self.find(u)
        pv = self.find(v)

        if pu == pv:
            return False

        if self.ranks[pu] > self.ranks[pv]:
            self.parents[pv] = pu
        elif self.ranks[pu] < self.ranks[pv]:
            self.parents[pu] = pv
        else:
            self.parents[pv] = pu
            self.ranks[pu] += 1

        return True

    def find(self, u: int) -> int:
        while self.parents[u] != u:
            self.parents[u] = self.parents[self.parents[u]]
            u = self.parents[u]

        return u

class Solution:
    def validTree(self, n: int, edges: List[List[int]]) -> bool:
        if len(edges) != n - 1:
            return False

        node = UnionFind(n)

        for edge in edges:
            if not node.union(edge[0], edge[1]):
                return False

        return True
```

Time Complexity: O(N⋅α(N)).
Space Complexity: O(N).
