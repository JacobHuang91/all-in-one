---
title: 253. Meeting Rooms II
tags: LeetCode
categories: LeetCode
date: 2020-09-23 20:59:53
keywords:
description:
cover:
top_img:
toc:
toc_number:
copyright:
indexing:
layout: post
---

## YouTube Video

## Problem

Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si < ei), find the minimum number of conference rooms required.

Example 1:

```
Input: [[0, 30],[5, 10],[15, 20]]
Output: 2
```

Example 2:

```
Input: [[7,10],[2,4]]
Output: 1
```

NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.

## Code

```python
class Solution:
    def minMeetingRooms(self, intervals: List[List[int]]) -> int:
        if not intervals:
            return 0

        min_ends = []
        intervals.sort(key= lambda x: x[0])

        heapq.heappush(min_ends, intervals[0][1])


        for interval in intervals[1:]:
            min_end = heapq.heappop(min_ends)

            if interval[0] >= min_end:
                min_end = interval[1]
            else:
                heapq.heappush(min_ends, interval[1])

            heapq.heappush(min_ends, min_end)

        return len(min_ends)
```

```java
class Solution {
    public int minMeetingRooms(int[][] intervals) {
         if(intervals == null || intervals.length == 0) return 0;

        Arrays.sort(intervals, (a, b) -> (a[0] - b[0]));
        PriorityQueue<int[]> heap = new PriorityQueue<>(intervals.length, (a, b) -> (a[1] - b[1]));
        heap.offer(intervals[0]);

        for(int i = 1; i < intervals.length; i++){
            // 会先把end小的拿出来，看是不是能在它结束之后进行下一个会议
            // 如果不行只能再开一个房间
            int[] minEnd = heap.poll();
            // 不需要开房间，进行融合
            if(intervals[i][0] >= minEnd[1]){
                minEnd[1] = intervals[i][1];
            } else {
                // 需要一个新房间
                heap.offer(intervals[i]);
            }

            heap.offer(minEnd);
        }

        return heap.size();
    }
}
```
